<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Tímarit</title>
    <!--link rel="stylesheet" href="./style.css"-->
    <!--link rel="icon" href="./favicon.ico" type="image/x-icon"-->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    <!-- CSS code below -->
    <style>
        :root{
            /* root variables are available in the whole document.*/
            /* In this document the 'root' tag is the '<html>' tag.*/

            /* Set the font-size to 62.5% to makes it easier to working with 'rem'.*/
            /* 62.5% font-size is equal to 10px and 1rem in most browsers*/
            font-size: 62.5%; /* 62.5% == 10px == 1rem */
        }
        body {
            visibility: hidden;
        }
        h1 {
            font-size: 2.5vw;
            padding: 4rem 10vw
        }
        .grid-container {
            display: grid;
            grid-template-columns: 0.7fr 1fr 1fr 1.3fr;
            gap: 0.5rem 5rem;
            padding: 0rem 10vw
        }
        @media only screen and (max-width: 768px) {
            /* For mobile phones, if the browser window is 768px or smaller. */
            h1 {
                font-size: 6vw;
            }
            .grid-container {
                grid-template-columns: 1fr;
            }
        }
        .grid-container > div {
            display: flex; /* or inline-flex */
            flex-direction: column; /* row | row-reverse | column | column-reverse */
            gap: 1rem;
            font-size: 1.8rem;
            padding: 4rem 0rem
        }
        .grid-container > div > span {
            text-align: left;
            font-size: 1.2rem;
        }
        #bil {
            height: 3rem;
        }
        #chart-container{
            position: relative;
            height: 80vh;
            width: max(97vw, 120rem);
            padding: 0rem 1vw;
        }
    </style>

    <!-- JavaScript code below -->
    <script type="text/javascript">
        // Declaring a function:
        function domReady(callback) {
            document.readyState === 'interactive' || document.readyState === 'complete'
                ? callback()
                : document.addEventListener('DOMContentLoaded', callback);
        }

        // Calling the function and passing in a callback-function as a parameter:
        domReady(() => {
            // Display body when DOM is loaded:
            document.body.style.visibility = 'visible';
        });
    </script>
  </head>

  <!-- HTML code below -->
  <body>
    <main>
        <h1>Örvar Sigþórsson - Diplóma í rafiðnfræði - Lokaverkefni 2024</h1>
        <div class="grid-container">
            <div id="skil">
                Skil:
            </div>
            <div id="skyrsla">
                Skýrslan:
            </div>
            <div id="verkefni">
                Tilraunaverkefnið:
            </div>
            <div id="hugtok">
                [24] Heimildir leit og hugtök:
            </div>
        </div>

	<div id="bil"></div>

        <h1>Verkáætlun fyrir lokaverkefni</h1>
        <div id="chart-container">
            <canvas id="chart"></canvas>
        </div>
    </main>

    <!-- JavaScript code below -->
	<script type="text/javascript">
        // --- Defining and implementing the 'ScalesManager' ---
        function getScalesManager(_length, _startPoint = 1.0, _resolution = 'none'){
            // Private variables:
            const scales = {
                'year': [12, 1],
                'weeks': [52, 1],
                'week': [7, 1],
                'day': [24, 0],
                'hour': [60, 0],
                'minute': [60, 0],
                'second': [60, 0],
                'degrees': [360, 0],
                // default: [null, 0],
            };
            const min = 0.0;
            const max = _length;
            let startPoint = _startPoint;
            const resolution = scales[_resolution][0] || null;
            const zeroOrOne = scales[_resolution][1] || 0;
            // Constructor:
            (() => {
                // ...
            })(); 
            // Private methods:
            function ifNegativeNumbers(num){
                if(resolution && num < 0.0){
                    num = resolution + num;
                }
                return num;
            }
            function convertWeeksToWeeksAndDays(weeks, scale = 0){
                weeks = ifNegativeNumbers(weeks + scale);
                // Calculate the integer part for weeks:
                const integerWeeks = Math.floor(weeks);
                // Calculate the decimal part for days:
                const decimalDays = (weeks - integerWeeks) * 7;
                const integerDays = Math.round(decimalDays); // Rounding to the nearest whole day.
                return [integerWeeks || 52, integerDays]; // Week 0 is week 52.
            }
            // Public interface:
            return {
                getScale(){
                    return -startPoint;
                },
                getMin(){
                    return Math.ceil(min);
                },
                getMax(){
                    return Math.ceil(max);
                },
                scaleCallback(x){
                    return (ifNegativeNumbers(startPoint + x) % resolution) + zeroOrOne;
                },

                // Tooltip 'item' passed to thes callbacks implement the following interface:
                // {
                //   chart: ChartJS,  // The chart the tooltip is being shown on.
                //   label: string,  // Label for the tooltip.
                //   parsed: object,  // Parsed data values for the given 'dataIndex' and 'datasetIndex'.
                //   raw: object,  // Raw data values for the given 'dataIndex' and 'datasetIndex'.
                //   formattedValue: string,  // Formatted value for the tooltip.
                //   dataset: object,  // The dataset the item comes from.
                //   datasetIndex: number,  // Index of the dataset the item comes from.
                //   dataIndex: number,  // Index of this data item in the dataset.
                //   element: Element,  // The chart element (point, arc, bar, etc.) for this tooltip item.
                // }
                labelCallback(item){
                    //console.log('item: ', item);
                    let weeks, days, str;
                    [weeks, days] = convertWeeksToWeeksAndDays(item.raw[0], startPoint + zeroOrOne);
                    str = `  Frá viku: ${weeks} og ${days} dagar  -  `;
                    [weeks, days] = convertWeeksToWeeksAndDays(item.raw[1], startPoint + zeroOrOne);
                    str += `til viku: ${weeks} og ${days} dagar.`;
                    return item.formattedValue = str;
                },
                footerCallback(items){
                    //console.log('items: ', items);
                    const duration = items[0].raw[1] - items[0].raw[0];
                    const [weeks, days] = convertWeeksToWeeksAndDays(duration);
                    return `Tímaspan: ${weeks} og ${days} dagar.`;
                },
            };
        };



        // --- Defining and implementing the 'LabelsAndDataManager' ---
        function getLabelsAndDataManager(){
            // Private variables:
            let countReferences = 0;
            let layerDepth = 0;
            const labelsText = [];
            const labelsPos = [];
            const texts = [];
            const groups = {};
            const colors = [
                [],
            ];
            const durations = [
                [],
            ];
            // Constructor:
            (() => {
                // ...
            })(); 
            // Private methods:
            function calcBeginAndEnd(groupID, move, duration, depth = 0){
                // If the groupID is undefined, use zero and a new group is declared.
                const group_position = groupID in groups ? groups[groupID] : 0.0;
                let begin, end;
                if(depth === 0){
                    // This is the first 'duration' added to this lable.
                    begin = move + group_position;
                    end = begin + duration;
                    labelsPos.push(end);
                    groups[groupID] = end;
                }
                else{
                    // Other added 'durations' to this lable take reference from the first 'duration'.
                    const label_position = labelsPos[labelsPos.length-1];
                    // If 'group_position' is behind 'label_position': then use 'label_position',
                    // but if 'group_position' is further ahead; then use 'group_position'.
                    const pos = Math.max(0.0, group_position - label_position); //<-Not accepting a number below zero.
                    // If this is not the first 'duration', negative position is not possible,
                    // because this 'duration' begins where the last one ended.
                    begin = Math.max(0.0, pos + move); //<-Not accepting a number below zero.
                    end = begin + duration;
                    
                    labelsPos[labelsPos.length-1] += end;
                    groups[groupID] = labelsPos[labelsPos.length-1];
                }
                return [begin, end];
            }
            function fillLayers(){
                durations.forEach( layer => {
                    while(durations[0].length > layer.length + 1){
                        layer.push([0.0, 0.0]);
                    }
                });
                colors.forEach( layer => {
                    while(colors[0].length > layer.length + 1){
                        layer.push("");
                    }
                });
            }
            // Public interface:
            return {
                add(groupID, color, move, duration, label, text, withReference = true){
                    // Using the JS 'Destructuring assignment' syntax:
                    //const [begin, end] = calcBeginAndEnd(groupID, move, duration);

                    durations[0].push( calcBeginAndEnd(groupID, move, duration) );
                    colors[0].push(color);

                    ++countReferences;
                    labelsText.push(withReference ? `${label} [${countReferences}]` : label);
                    texts.push(withReference ? `[${countReferences}] ${text}` : text);

                    fillLayers();
                    let depth = 1;
                    return {
                        // The 'add' function returns another function named 'addLayer',
                        // 'addLayer' will add another 'duration' to the same label.
                        // NOTE: This tow functions can be chained:  .add(s,s,f,f,s,s,/b).addLayer(s,s,f,f);
                        addLayer(groupID, color, move, duration){
                            if(durations[depth]) {
                                console.log("Depth already exists.");
                            }
                            else{
                                console.log("Make new depth.");
                                durations.push([]);
                                colors.push([]);
                                fillLayers(); // Fill the column with zero-duration, until it's at the current label.
                            }
                            durations[depth].push( calcBeginAndEnd(groupID, move, duration, depth) );
                            colors[depth].push(color);

                            ++depth;
                            return this;
                            // The 'addLayer' function returns itself, so it can be chained,
                            // like so:  .add(s,s,f,f,s,s,/b).addLayer(s,s,f,f).addLayer(s,s,f,f).addLayer(s,s,f,f);
                        },
                    };
                    // Now to explain these two functions, 'add' and 'addLayer': (they both add a 'duration' to the chart)
                    // 'add' is used to add a row to the to the first column, each row has a corresponding label.
                    // 'addLayer' will add a column and place the 'duration' at the current row.
                    // 'depth' is the number of columns the chart has.
                },
                getReferenceCount(){
                    return countReferences;
                },
                getLabels(){
                    return labelsText;
                },
                getTexts(){
                    return {
                        labels: labelsText, 
                        texts: texts, 
                        groups: groups
                    };
                },
                scaleData(scale){
                    // This function will move the all data left or right on the x-scales.
                    for(let i = 0; i < durations[0].length ; ++i){
                        durations[0][i][0] += scale;
                        durations[0][i][1] += scale;
                    }
                },
                getChartData(borderWidth, borderRadius, barPercentage, opacity){
                    // the function will generate the data for the chart.
                    const dataSets = [];
                    for( let i = 0; i < durations.length ; ++i){
                        // Creating colors with alpha channel:
                        // Clone the colors array:
                        const alphaColors = [...colors[i]];
                        alphaColors.forEach((c, j) => {
                            if(c.length && c.length > 0){
                                alphaColors[j] = `${c.slice(0, -1)}, ${opacity})`;
                            }
                        });
                        dataSets.push({
                            label: "Tímaspan " + (i+1),
                            data: durations[i],
                            borderSkipped: false,
                            borderWidth: borderWidth,
                            borderRadius: borderRadius,
                            borderColor: colors[i],
                            backgroundColor: alphaColors,
                            barPercentage: barPercentage,
                        });
                    }
                    return {
                        // Chart-JS will use this object.
                        labels: labelsText,
                        datasets: dataSets,
                    };
                },
            };
        };
        


        // --- Defining and implementing the 'EventsManager' ---
        function getEventsManager(showCurrentWeek = null){
            // 'showCurrentWeek' has to implement the following interface:
            //  {
            //    scale: number,  // Get it from the 'ScalesManager'.
            //    yearStartDay: number,  // Between 0 and 6.
            //    color: string,  // E.g: 'rgb(255, 99, 132)' and 'rgb(255, 99, 132, 0.5)'.
            //  }

            // Private variables:
            const events = [];
            const texts = [];
            let refCount = 0;
            // Constructor:
            (() => {
                if(showCurrentWeek instanceof Object){
                    events.push({
                        pos: getCurrentWeek(showCurrentWeek.scale, showCurrentWeek.yearStartDay),
                        color: showCurrentWeek.color,
                        name: "Í dag",
                        ref: false,
                    });
                    texts.push("");
                }
            })(); 
            // Private methods:
            function getCurrentWeek(scale = 0, yearStartDay = 0){
                const currentDate = new Date();
                // Set the target date to the first day of the year:
                const targetDate = new Date(currentDate.getFullYear(), 0, 1);
                // Calculate the difference in milliseconds between the current date and the target date:
                const timeDifference = currentDate - targetDate;
                // Calculate the number of days passed:
                const daysPassed = Math.floor(timeDifference / (24 * 60 * 60 * 1000));
                // Calculate the current week number:
                return scale + ((daysPassed + yearStartDay) / 7);
            };
            // Public interface:
            return {
                add(pos, color, name, text, withReference = true){
                    events.push({
                        pos: pos,
                        color: color,
                        name: name,
                        ref: withReference,
                    });
                    texts.push(text);
                },
                setReferencesNumber(referencesNum){
                    events.forEach((event, i) => {
                        if(event.ref){
                            event.name += ` [${referencesNum}]`;
                            texts[i] = `[${referencesNum}] ${texts[i]}`;
                            ++referencesNum;
                        }
                    });
                    refCount = referencesNum;
                },
                getReferencesNumber(){
                    return refCount;
                },
                getTexts(){
                    return texts;
                },
                getChartAnnotations(){
                    const annotations = {};
                    events.forEach((event, i) => {
                        annotations['line-'+i] = {
                            type: 'line',
                            xMin: event.pos,
                            xMax: event.pos,
                            borderColor: event.color,
                            borderWidth: 3,
                            label: {
                                backgroundColor: event.color,
                                content: event.name,
                                display: true,
                                position: 'center', // start | center | end
                                rotation: 90,
                            },
                        };
                    });
                    return annotations;
                },
            };
        };



        // --- Global variables ---
        const _COLORS = {
            red: 'rgb(255, 99, 132)',
            orange: 'rgb(255, 159, 64)',
            yellow: 'rgb(255, 205, 86)',
            green: 'rgb(75, 192, 192)',
            blue: 'rgb(54, 162, 235)',
            purple: 'rgb(153, 102, 255)',
            grey: 'rgb(201, 203, 207)'
        };
        function _DAY(day){
            return 0.14286 * day;
        }

        // --- Create instances of the 'ScalesManager' ---
        const sM = getScalesManager(23, -3, 'weeks');
        // --- Create instances of the 'LabelsAndDataManager' ---
        const ldM = getLabelsAndDataManager();
        // --- Create instances of the 'EventsManager' ---
        const eM = getEventsManager({scale: sM.getScale(), yearStartDay: 0, color: 'gray'});



        // --- Text for 'hugtök' ---
        const concepts = [
            "Skilgreining á kerfum.",
            "Skilgreining á iðnstýringum.",
            "Skilgreining á iðntölvum.",
            "Skilgreining á skjámyndakerfum.",
            "Skilgreining áGNU/Linux og RPi (Raspberry Pi) smátölvum.",
            "Skilgreining á HTML (HyperText Markup Language).",
            "Skilgreining á CSS (Cascading Style Sheets; oft kallað stílsnið).",
            "Skilgreining á JS (JavaScript).",
            "Skilgreining á vefþjóni (backend eða bakendi).",
            "Skilgreining á AWS (Amazon Web Services) og Supabase.",
            "Skilgreining á vefsíðu (frontend eða framendi).",
            "Skilgreining á gagnagrunni (Database eða DB).",
            "Skilgreining á vafra (web-browser).",
            "Vitna í Mozilla(Firefox), Google(Chrome), Brave eða KDE(Konqueror).",
            "Skilgreining á HTTP/HTTPS (Hypertext Transfer Protocol /Secure).",
            "Skilgreining á IoT (The Internet of Things) og MQTT (the standard for IoT messaging).",
            "Skilgreining á TLS (Transport Layer Security, líka kallað SSL).",
            "Skilgreining á SVG (Scalable Vector Graphics) og tengingunni við HTML og vafra.",
            "Skilgreining á Inkscape (vector graphics editor).",
            "Hvernig nýtist LHTTP safn þegar sett er upp á Siemens Iðntölvu?",
            "Skilgreining á SCADA staðlinum.",
        ];



        // --- Text for 'skýrsla' and 'verkefni' ---
        // 1. argument = Framhal af tímanum fyrir ofan.        
        // 2. argument = Litur timabilsins á línuritinu.
        // 3. argument = Byrjun tímabils(0 er endir timabilsins á undan).
        // 4. argument = Lengd tímabils.
        // 5. argument = Stutt lýsing.
        // 6. argument = Nákvæmari lýsing.
        ldM.add('skyrsla', 'rgb(153, 102, 255)', 0.0, 1.5, 'Velja leið - Siemens', 'Bera saman leiðir og velja ódýrustu leiðina sem Siemens býður upp á til að fjartengjast skjámyndakerfum. Skrifa punkta.');
        ldM.add('skyrsla', 'rgb(153, 102, 255)', -1.0, 2.0, 'Kostnaðaráætlun - Siemens', 'Útbúa einhverskonar kostnaðaráætlun byggða á Siemens.');
        ldM.add('skyrsla', 'rgb(153, 102, 255)', -0.5, 1.5, 'Heimildaleit - Siemens', 'Skoða heimasíðu Siemens vandlega og skrifa texta.');
        ldM.add('skyrsla', 'rgb(153, 102, 255)', 0.0, 2.0, 'Heimildaleit - Ský og Firebase', 'Skoða og taka saman upplýsingar um skýjaþjónustur sem og Firebase.');
        ldM.add('skyrsla', 'rgb(153, 102, 255)', -1.0, 1.0, 'Heimildaleit - mySCADA', 'Finna upplýsingar og athuga verð fyrir sambærilega aðferð og valin var hjá Siemens. Skrifa punkta.');
        ldM.add('skyrsla', 'rgb(153, 102, 255)', 0.0, 2.0, 'Skipulag skýrslu', 'Ákveða hvaða efni á að vera til umfjöllunar í 1. inngangi, í 2. meginmál eða í 2.5 tilraunaverkefnið.');
        ldM.add('skyrsla', 'rgb(153, 102, 255)', 0.0, 4.0, 'Tilraunaverkefnið', 'Byrja á texta um tilraunaverkefnið.');
        ldM.add('skyrsla', 'rgb(153, 102, 255)', -2.0, 2.0, 'Lokaorð og samantekt', 'Skrifa lokaorð og samantekt.');
        ldM.add('skyrsla', 'rgb(153, 102, 255)', -1.0, 2.0, 'Formáli og inngangur', 'Skrifa formála og inngang.');
        ldM.add('skyrsla', 'rgb(153, 102, 255)', -4.0, 6.0, 'Samstilling', 'Samstilla og yfirfara allan texta sem kominn er.');
        ldM.add('skyrsla', 'rgb(153, 102, 255)', -1.0, 2.0, 'Heimildaskrá og almennur frágangur', 'Yfirfara heimildaskrá og yfirfara skýrslu í heild.');

        ldM.add('verkefni', 'rgb(153, 102, 255)', -3.0, 2.0, 'Upplýsingasöfnun - Smith og Norland', 'Hafa samband við Smith og Norland sem er umboðsaðili fyrir Siemens og fá verð á iðntölvum og leyfum.');
        ldM.add('verkefni', 'rgb(153, 102, 255)', -1.5, 3.0, 'Upplýsingasöfnun - Siemens', 'Setja upp TIA Portal og skoða leiðir sem eru í boði.');
        ldM.add('verkefni', 'rgb(153, 102, 255)', -1.0, 1.0, 'Útvega leyfi', 'Útvega leyfi fyrir TIA sem og iðntölvu sem hentar fyrir verkefnið.');
        ldM.add('verkefni', 'rgb(153, 102, 255)', -1.5, 0.5, 'Setja upp Raspberry Pi', 'Setja upp RPi svo hægt sé að prófa ýmsar aðferðir til að tengjast iðntölvunni.');
        ldM.add('verkefni', 'rgb(153, 102, 255)', 4.0, 2.5, 'Upplýsingaöflun - Vefþjón', 'Skoða hvaða þjónustur bjóða upp á vefþjón á skýi.');
        ldM.add('verkefni', 'rgb(153, 102, 255)', -1.5, 1.5, 'Upplýsingaöflun - HTTPS samskipti', 'Skoða HTTP samskipti sem og aðrar samskiptaaðferðir til samanburðar (IoT/MQTT).');
        ldM.add('verkefni', 'rgb(153, 102, 255)', 0.0, 1.0, 'Upplýsingaöflun - Andor ehf', 'Fá verð og hugmyndir frá Andor ehf varðandi mySCADA.');
        ldM.add('verkefni', 'rgb(153, 102, 255)', -0.5, 1.0, 'Upplýsingaöflun - mySCADA', 'Skoða framboðið hjá mySCADA.');
        ldM.add('verkefni', 'rgb(153, 102, 255)', 0.25, 2.25, 'Útfæra samskiptaleið', 'Koma upp samskiptaleið á milli RPi og iðntölvunnar.');
        ldM.add('verkefni', 'rgb(153, 102, 255)', 0.5, 2.5, 'Upplýsingaöflun - HTTPS/OAuth', 'Skoða HTTPS/OAuth og finna leið til að koma upp öruggari tengingu fyrir veraldarvefinn.');
        ldM.add('verkefni', 'rgb(153, 102, 255)', -1.0, 2.0, 'Færa samskipti yfir á vefþjónn', 'Færa samskipti af RPi og yfir á vefþjón.');
        ldM.add('verkefni', 'rgb(153, 102, 255)', -0.25, 2.0, 'Útbúa viðauka', 'Taka saman og útbúa dæmi sem fara í viðauka, t.d. LHTTP og MQTT í TIA Portal.');

        ldM.add('hugtok', 'rgb(153, 102, 255)', -1.0, 0.55, `Heimildaleit og hugtök (alls ${concepts.length} atriði)`, '')
        .addLayer('hugtok', 'rgb(153, 102, 255)', 0.0, 0.55)
        .addLayer('hugtok', 'rgb(153, 102, 255)', 0.0, 0.55)
        .addLayer('hugtok', 'rgb(153, 102, 255)', 0.0, 0.55)
        .addLayer('hugtok', 'rgb(153, 102, 255)', 0.0, 0.55)
        .addLayer('hugtok', 'rgb(153, 102, 255)', 0.0, 0.55)
        .addLayer('hugtok', 'rgb(153, 102, 255)', 0.0, 0.55)
        .addLayer('hugtok', 'rgb(153, 102, 255)', 0.0, 0.55)
        .addLayer('hugtok', 'rgb(153, 102, 255)', 0.0, 0.55)
        .addLayer('hugtok', 'rgb(153, 102, 255)', 0.0, 0.55)
        .addLayer('hugtok', 'rgb(153, 102, 255)', 0.0, 0.55)
        .addLayer('hugtok', 'rgb(153, 102, 255)', 0.0, 0.55)
        .addLayer('hugtok', 'rgb(153, 102, 255)', 0.0, 0.55)
        .addLayer('hugtok', 'rgb(153, 102, 255)', 0.0, 0.55)
        .addLayer('hugtok', 'rgb(153, 102, 255)', 0.0, 0.55)
        .addLayer('hugtok', 'rgb(153, 102, 255)', 0.0, 0.55)
        .addLayer('hugtok', 'rgb(153, 102, 255)', 0.0, 0.55)
        .addLayer('hugtok', 'rgb(153, 102, 255)', 0.0, 0.55)
        .addLayer('hugtok', 'rgb(153, 102, 255)', 0.0, 0.55)
        .addLayer('hugtok', 'rgb(153, 102, 255)', 0.0, 0.55)
        .addLayer('hugtok', 'rgb(153, 102, 255)', 0.0, 0.55);

        ldM.add('vorn', 'rgb(153, 102, 255)', 8.0+_DAY(2), 1.0, 'Undirbúa vörn', '', false)
        .addLayer('vorn', 'rgb(153, 102, 255)', 7.0+_DAY(2), 2.0);

        ldM.scaleData(sM.getScale());
        const data = ldM.getChartData( 3.0, 8.0, 1.0, 0.5);
        


        // --- Text for 'skil' ---
        eM.add(3.0,         'gray', "Gleðilegt nýtt ár 2024!", null, false); // 01jan/00+0
        eM.add(0.0+_DAY(4),'green', "Umsókn um lokaverkefni", "Fylla inn umsókn um lokaverkefni (15. desember 2023)."); // 15des/11+4
        eM.add(6.0,        'green', "Uppsetning skýrslu og verkáætlun", "a) Setja upp skýrslu og ákveða kaflaskiptingu. b) Útbúa Gantt rit og skipuleggja tíma (22. janúar)."); // 22des/04+0
        eM.add(6.0+_DAY(4), 'gray', "IEEE heimildanotkun fyrirlestur", "Fyrirlestur frá skólanum um IEEE heimildanotkun (26. janúar - 1 klst 12:00-13:00)."); // 26jan/04+4
        eM.add(9.0,          'red', "Fyrri áfangaskil", "Vera búinn að vinna í gegnum kaflana í meginmáli (12. febrúar)."); // 12feb/07+0
        eM.add(11.0,         'red', "Seinni áfangaskil", "Fræðin og undirbúningur fyrir úrvinnslu á mælingum og/eða gögnum á að liggja að mestu fyrir í skýrslunni (26. febrúar)."); // 26feb/09+0
        eM.add(12.0+_DAY(2), 'red', "Miðannarvörn á seinni skilum", "Kynning + powerpoint og spurningar frá kennara (4. mars - 8. mars )."); // 04mar/10+2
        eM.add(19.0,         'red', "Lokaskil", "Lokaskil, hér á skýslan að vera full búin (22. apríl)."); // 22apr/17+0
        eM.add(21.0+_DAY(4), 'red', "Varnir á lokaverkefni", "Varnir á lokaverkefni, upplýsingar koma seinna (miðjan maí)."); // 10maí/19+4
        eM.add(22.0+_DAY(2), 'red', "Skil á skýrslu inn á skemma.is", "Skil á skýrslu inn á skemma.is eftir vörn, áfanga lokið!"); // 15maí/20+2
        eM.setReferencesNumber(ldM.getReferenceCount());



        // Configuration for the ChartJS:
        const config = {
            type: 'bar',
            data: data,
            options: {
                indexAxis: 'y',
                responsive: true,
                maintainAspectRatio: true,
                scales: {
                    x: {
                        min: sM.getMin(),
                        max: sM.getMax(),
                        stacked: true,
                        ticks: {
                            stepSize: 1,
                            callback: sM.scaleCallback,
                        },
                        title: {
                            display: true,
                            text: 'Vikur',
                            font: {
                                size: 18,
                                weight: 'bolder',
                            },
                        },
                    },
                    y: {
                        stacked: true,
                    },
                },
                plugins: {
                    legend: {
                        display: false,
                        position: 'top',
                    },
                    title: {
                        display: false,
                        text: 'Verkáætlun fyrir lokaverkefni',
                        font: {
                            size: 32,
                        },
                    },
                    annotation: {
                        annotations: eM.getChartAnnotations(),
                    },
                    tooltip: {
                        callbacks: {
                            label: sM.labelCallback,
                            footer: sM.footerCallback,
                        },
                    },
                },
            },
        };
        // Setting up and rendering the ChartJS:
        const canvas = document.getElementById('chart');
        const chart = new Chart(canvas, config);
        chart.update();

        

        // HTML - Creating lists:
        const nodeSkil = document.getElementById("skil");
        const nodeSkyrsla = document.getElementById("skyrsla");
        const nodeVerkefni = document.getElementById("verkefni");
        const nodeHugtok = document.getElementById("hugtok");
        
        eM.getTexts().forEach(function(text, i){
            if(text){
                const node = document.createElement('span');
                const textnode = document.createTextNode(text);
                node.appendChild(textnode);
                nodeSkil.appendChild(node);
            }
        });

        // Using the JS 'Destructuring assignment' syntax:
        const {texts} = ldM.getTexts();
        texts.forEach(function(text, i){
            if(text === null || text.legend === 0){
                return;
            }
            const node = document.createElement('span');
            const textnode = document.createTextNode(text);
            node.appendChild(textnode);
            if(i < 11){ // 'skyrsla'
                nodeSkyrsla.appendChild(node);
            }
            else if(i < 23){ // 'verkefni'
                nodeVerkefni.appendChild(node);
            }
        });

        concepts.forEach(function(item, i){
            const node = document.createElement('span');
            const textnode = document.createTextNode((i+1) +". "+ item);
            node.appendChild(textnode);
            nodeHugtok.appendChild(node);
        });
    </script>
  </body>
</html>